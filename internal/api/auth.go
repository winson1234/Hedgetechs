package api

import (
	"context"
	"crypto/rand"
	"database/sql"
	"encoding/json"
	"fmt"
	"math/big"
	"net/http"
	"strings"
	"time"

	"brokerageProject/internal/database"
	"brokerageProject/internal/middleware"
	"brokerageProject/internal/models"
	"brokerageProject/internal/services"
	"brokerageProject/internal/utils"

	"github.com/google/uuid"
)

// HandleRegister handles user registration requests
func HandleRegister(w http.ResponseWriter, r *http.Request) {
	var req models.RegisterRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		utils.RespondWithJSONError(w, http.StatusBadRequest, "invalid_request", "Invalid request body")
		return
	}

	// Validate required fields
	if req.Email == "" || req.Password == "" || req.FirstName == "" || req.LastName == "" {
		utils.RespondWithJSONError(w, http.StatusBadRequest, "validation_error", "Email, password, first name, and last name are required")
		return
	}

	// Hash password
	hashedPassword, err := utils.HashPassword(req.Password)
	if err != nil {
		utils.RespondWithJSONError(w, http.StatusInternalServerError, "server_error", "Failed to process password")
		return
	}

	// Insert directly into users table
	pool, err := database.GetPool()
	if err != nil {
		utils.RespondWithJSONError(w, http.StatusInternalServerError, "database_error", "Failed to connect to database")
		return
	}
	ctx := context.Background()

	// Generate UUID for user
	userID := uuid.New()
	createdAt := time.Now()

	// user_id will be auto-generated by the database sequence
	query := `
		INSERT INTO users
		(id, first_name, last_name, email, hash_password, phone_number, country, is_active, created_at, last_updated_at)
		VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
	`

	_, err = pool.Exec(ctx, query,
		userID,
		req.FirstName,
		req.LastName,
		req.Email,
		hashedPassword,
		req.PhoneNumber,
		req.Country,
		true, // is_active defaults to true
		createdAt,
		time.Now(),
	)

	if err != nil {
		// Check for duplicate email
		if strings.Contains(err.Error(), "users_email_key") {
			utils.RespondWithJSONError(w, http.StatusConflict, "duplicate_email", "Email already registered")
			return
		}
		utils.RespondWithJSONError(w, http.StatusInternalServerError, "database_error", fmt.Sprintf("Failed to create user account: %v", err))
		return
	}

	// Success response
	response := models.RegisterResponse{
		Message: "Registration successful. You can now log in.",
		Success: true,
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusCreated)
	json.NewEncoder(w).Encode(response)
}

// HandleCheckStatus checks the registration status of a user
func HandleCheckStatus(w http.ResponseWriter, r *http.Request) {
	var req models.CheckStatusRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		utils.RespondWithJSONError(w, http.StatusBadRequest, "invalid_request", "Invalid request body")
		return
	}

	if req.Email == "" {
		utils.RespondWithJSONError(w, http.StatusBadRequest, "validation_error", "Email is required")
		return
	}

	pool, err := database.GetPool()
	if err != nil {
		utils.RespondWithJSONError(w, http.StatusInternalServerError, "database_error", "Failed to connect to database")
		return
	}
	ctx := context.Background()

	var isActive bool
	query := `SELECT is_active FROM users WHERE email = $1`
	err = pool.QueryRow(ctx, query, req.Email).Scan(&isActive)

	if err != nil {
		response := models.CheckStatusResponse{
			Status:  "not_found",
			Message: "No account found for this email",
		}
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(response)
		return
	}

	var status string
	var message string
	if isActive {
		status = "approved"
		message = "Your account is active. You can log in"
	} else {
		status = "inactive"
		message = "Your account is inactive. Please contact support"
	}

	response := models.CheckStatusResponse{
		Status:  status,
		Message: message,
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(response)
}

// HandleLogin handles user login requests
func HandleLogin(w http.ResponseWriter, r *http.Request) {
	var req models.LoginRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		utils.RespondWithJSONError(w, http.StatusBadRequest, "invalid_request", "Invalid request body")
		return
	}

	if req.Email == "" || req.Password == "" {
		utils.RespondWithJSONError(w, http.StatusBadRequest, "validation_error", "Email and password are required")
		return
	}

	pool, err := database.GetPool()
	if err != nil {
		utils.RespondWithJSONError(w, http.StatusInternalServerError, "database_error", "Failed to connect to database")
		return
	}
	ctx := context.Background()

	// Check users table directly
	var (
		userID         uuid.UUID
		hashedPassword string
		isActive       bool
	)

	query := `
		SELECT id, hash_password, is_active
		FROM users
		WHERE email = $1
	`

	err = pool.QueryRow(ctx, query, req.Email).Scan(
		&userID, &hashedPassword, &isActive,
	)

	if err != nil {
		utils.RespondWithJSONError(w, http.StatusUnauthorized, "authentication_error", "Invalid email or password")
		return
	}

	// Check if account is active
	if !isActive {
		response := models.LoginResponse{
			Message: "Your account is inactive. Please contact support",
			Status:  "inactive",
		}
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusForbidden)
		json.NewEncoder(w).Encode(response)
		return
	}

	// Verify password
	if err := utils.VerifyPassword(hashedPassword, req.Password); err != nil {
		utils.RespondWithJSONError(w, http.StatusUnauthorized, "authentication_error", "Invalid email or password")
		return
	}

	// Update last_login
	updateLoginQuery := `UPDATE users SET last_login = $1 WHERE id = $2`
	pool.Exec(ctx, updateLoginQuery, time.Now(), userID)

	// Generate JWT token
	token, err := utils.GenerateJWT(userID, req.Email)
	if err != nil {
		utils.RespondWithJSONError(w, http.StatusInternalServerError, "server_error", "Failed to generate authentication token")
		return
	}

	// Get user info
	var user models.UserInfo
	getUserQuery := `
		SELECT id, user_id, email, first_name, last_name, phone_number, country, is_active
		FROM users
		WHERE id = $1
	`
	err = pool.QueryRow(ctx, getUserQuery, userID).Scan(
		&user.ID,
		&user.UserID,
		&user.Email,
		&user.FirstName,
		&user.LastName,
		&user.PhoneNumber,
		&user.Country,
		&user.IsActive,
	)

	if err != nil {
		utils.RespondWithJSONError(w, http.StatusInternalServerError, "database_error", "Failed to retrieve user information")
		return
	}

	// Success response
	response := models.LoginResponse{
		Token:   token,
		User:    &user,
		Message: "Login successful",
		Status:  "approved",
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(response)
}

// generateOTP generates a random 6-digit OTP
func generateOTP() (string, error) {
	max := big.NewInt(1000000)
	n, err := rand.Int(rand.Reader, max)
	if err != nil {
		return "", err
	}
	return fmt.Sprintf("%06d", n.Int64()), nil
}

// generateResetToken generates a random reset token
func generateResetToken() (string, error) {
	b := make([]byte, 32)
	_, err := rand.Read(b)
	if err != nil {
		return "", err
	}
	return fmt.Sprintf("%x", b), nil
}

// HandleForgotPassword returns a handler that processes forgot password requests with rate limiting
func HandleForgotPassword(authStorage *services.AuthStorageService, emailSender services.EmailSender) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var req models.ForgotPasswordRequest
		if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
			utils.RespondWithJSONError(w, http.StatusBadRequest, "invalid_request", "Invalid request body")
			return
		}

		if req.Email == "" {
			utils.RespondWithJSONError(w, http.StatusBadRequest, "validation_error", "Email is required")
			return
		}

		ctx := r.Context()

		// CRITICAL: Check rate limit FIRST (3 attempts per hour per email)
		allowed, remaining, err := authStorage.CheckRateLimit(ctx, "forgot_password", req.Email, 3, 1*time.Hour)
		if err != nil {
			utils.RespondWithJSONError(w, http.StatusInternalServerError, "server_error", "Failed to check rate limit")
			return
		}

		if !allowed {
			response := map[string]interface{}{
				"error":               "rate_limit_exceeded",
				"message":             "Too many password reset attempts. Please try again later.",
				"retry_after_seconds": 3600,
			}
			w.Header().Set("Content-Type", "application/json")
			w.WriteHeader(http.StatusTooManyRequests)
			json.NewEncoder(w).Encode(response)
			return
		}

		pool, err := database.GetPool()
		if err != nil {
			utils.RespondWithJSONError(w, http.StatusInternalServerError, "database_error", "Failed to connect to database")
			return
		}

		// Constant-time user lookup (prevent timing attacks)
		// CRITICAL: Check users table, not pending_registrations
		// Only allow password reset for registered, active users
		var isActive bool
		var userFound bool
		query := `SELECT is_active FROM users WHERE email = $1`
		err = pool.QueryRow(ctx, query, req.Email).Scan(&isActive)

		if err == nil && isActive {
			userFound = true
		}

		// Always sleep to prevent timing attacks (even if user not found)
		time.Sleep(200 * time.Millisecond)

		// Generic response regardless of user existence (prevent email enumeration)
		response := models.ForgotPasswordResponse{
			Message: "If your email is registered and approved, you will receive a verification code shortly.",
			Status:  "success",
			Success: true,
		}

		// Only actually send OTP if user was found and approved
		if userFound {
			// Generate OTP
			otp, err := generateOTP()
			if err != nil {
				utils.RespondWithJSONError(w, http.StatusInternalServerError, "server_error", "Failed to generate OTP")
				return
			}

			// Store OTP in Redis with 10-minute TTL
			if err := authStorage.StoreOTP(ctx, req.Email, otp); err != nil {
				utils.RespondWithJSONError(w, http.StatusInternalServerError, "server_error", "Failed to store OTP")
				return
			}

			// Send OTP via email service (Console in dev, Resend in prod)
			if err := emailSender.SendOTP(ctx, req.Email, otp); err != nil {
				utils.RespondWithJSONError(w, http.StatusInternalServerError, "server_error", "Failed to send OTP email")
				return
			}
		}

		w.Header().Set("Content-Type", "application/json")
		w.Header().Set("X-RateLimit-Remaining", fmt.Sprintf("%d", remaining-1))
		json.NewEncoder(w).Encode(response)
	}
}

// HandleVerifyOTP returns a handler that processes OTP verification requests
func HandleVerifyOTP(authStorage *services.AuthStorageService) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var req models.VerifyOTPRequest
		if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
			utils.RespondWithJSONError(w, http.StatusBadRequest, "invalid_request", "Invalid request body")
			return
		}

		if req.Email == "" || req.OTP == "" {
			utils.RespondWithJSONError(w, http.StatusBadRequest, "validation_error", "Email and OTP are required")
			return
		}

		ctx := r.Context()

		// Validate OTP from Redis (auto-deletes on success - one-time use)
		valid := authStorage.ValidateOTP(ctx, req.Email, req.OTP)
		if !valid {
			response := models.VerifyOTPResponse{
				Message: "Invalid or expired OTP. Please request a new one.",
				Success: false,
			}
			w.Header().Set("Content-Type", "application/json")
			w.WriteHeader(http.StatusUnauthorized)
			json.NewEncoder(w).Encode(response)
			return
		}

		// OTP is valid - generate reset token
		resetToken, err := generateResetToken()
		if err != nil {
			utils.RespondWithJSONError(w, http.StatusInternalServerError, "server_error", "Failed to generate reset token")
			return
		}

		// Store reset token in Redis with 15-minute TTL
		if err := authStorage.StoreResetToken(ctx, resetToken, req.Email); err != nil {
			utils.RespondWithJSONError(w, http.StatusInternalServerError, "server_error", "Failed to store reset token")
			return
		}

		response := models.VerifyOTPResponse{
			Message:    "OTP verified successfully. You can now reset your password.",
			Success:    true,
			ResetToken: resetToken,
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(response)
	}
}

// HandleResetPassword returns a handler that processes password reset requests with session revocation
func HandleResetPassword(authStorage *services.AuthStorageService) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var req models.ResetPasswordRequest
		if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
			utils.RespondWithJSONError(w, http.StatusBadRequest, "invalid_request", "Invalid request body")
			return
		}

		if req.ResetToken == "" || req.NewPassword == "" {
			utils.RespondWithJSONError(w, http.StatusBadRequest, "validation_error", "Reset token and new password are required")
			return
		}

		// Validate password strength
		if len(req.NewPassword) < 8 {
			utils.RespondWithJSONError(w, http.StatusBadRequest, "validation_error", "Password must be at least 8 characters")
			return
		}

		ctx := r.Context()

		// Validate reset token from Redis (auto-deletes on success - one-time use)
		email, err := authStorage.ValidateResetToken(ctx, req.ResetToken)
		if err != nil {
			response := models.ResetPasswordResponse{
				Message: "Invalid or expired reset token. Please request a new OTP.",
				Success: false,
			}
			w.Header().Set("Content-Type", "application/json")
			w.WriteHeader(http.StatusUnauthorized)
			json.NewEncoder(w).Encode(response)
			return
		}

		// Hash new password
		hashedPassword, err := utils.HashPassword(req.NewPassword)
		if err != nil {
			utils.RespondWithJSONError(w, http.StatusInternalServerError, "server_error", "Failed to process password")
			return
		}

		pool, err := database.GetPool()
		if err != nil {
			utils.RespondWithJSONError(w, http.StatusInternalServerError, "database_error", "Failed to connect to database")
			return
		}

		// Update users table and get UUID
		var userUUID string
		updateUsersQuery := `
			UPDATE users
			SET hash_password = $1, last_updated_at = NOW()
			WHERE email = $2 AND is_active = true
			RETURNING id
		`
		err = pool.QueryRow(ctx, updateUsersQuery, hashedPassword, email).Scan(&userUUID)

		if err == sql.ErrNoRows {
			// User not found or not active
			utils.RespondWithJSONError(w, http.StatusNotFound, "not_found", "User not found or account inactive")
			return
		}

		if err != nil {
			// Database error
			utils.RespondWithJSONError(w, http.StatusInternalServerError, "database_error", "Failed to update password in users table")
			return
		}

		// CRITICAL: Revoke all sessions for this user (invalidate existing JWTs)
		if err := authStorage.RevokeSessions(ctx, userUUID); err != nil {
			// Log error but don't fail the request (password was already reset)
			fmt.Printf("[AUTH WARNING] Failed to revoke sessions for user %s: %v\n", userUUID, err)
		}

		response := models.ResetPasswordResponse{
			Message: "Password reset successfully. You can now log in with your new password.",
			Success: true,
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(response)
	}
}

// HandleChangePassword returns a handler that processes authenticated password change requests with session revocation
func HandleChangePassword(authStorage *services.AuthStorageService) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var req models.ChangePasswordRequest
		if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
			utils.RespondWithJSONError(w, http.StatusBadRequest, "invalid_request", "Invalid request body")
			return
		}

		if req.CurrentPassword == "" || req.NewPassword == "" {
			utils.RespondWithJSONError(w, http.StatusBadRequest, "validation_error", "Current password and new password are required")
			return
		}

		// Validate new password strength
		if len(req.NewPassword) < 8 {
			utils.RespondWithJSONError(w, http.StatusBadRequest, "validation_error", "New password must be at least 8 characters")
			return
		}

		// Check that new password is different from current
		if req.CurrentPassword == req.NewPassword {
			utils.RespondWithJSONError(w, http.StatusBadRequest, "validation_error", "New password must be different from current password")
			return
		}

		ctx := r.Context()

		// Extract user email from JWT context (injected by AuthMiddleware)
		email, err := middleware.GetUserEmailFromContext(ctx)
		if err != nil {
			utils.RespondWithJSONError(w, http.StatusUnauthorized, "authentication_error", "User email not found in context")
			return
		}

		pool, err := database.GetPool()
		if err != nil {
			utils.RespondWithJSONError(w, http.StatusInternalServerError, "database_error", "Failed to connect to database")
			return
		}

		// Get current password hash and UUID from users table
		var currentHashedPassword string
		var userUUID string
		userQuery := `SELECT id, hash_password FROM users WHERE email = $1`
		err = pool.QueryRow(ctx, userQuery, email).Scan(&userUUID, &currentHashedPassword)
		if err != nil {
			utils.RespondWithJSONError(w, http.StatusInternalServerError, "database_error", "Failed to retrieve user information")
			return
		}

		// Verify current password
		if err := utils.VerifyPassword(currentHashedPassword, req.CurrentPassword); err != nil {
			utils.RespondWithJSONError(w, http.StatusUnauthorized, "authentication_error", "Current password is incorrect")
			return
		}

		// Hash new password
		newHashedPassword, err := utils.HashPassword(req.NewPassword)
		if err != nil {
			utils.RespondWithJSONError(w, http.StatusInternalServerError, "server_error", "Failed to process new password")
			return
		}

		// Update users table
		updateUsersQuery := `UPDATE users SET hash_password = $1, last_updated_at = NOW() WHERE email = $2`
		_, err = pool.Exec(ctx, updateUsersQuery, newHashedPassword, email)
		if err != nil {
			utils.RespondWithJSONError(w, http.StatusInternalServerError, "database_error", "Failed to update password in users table")
			return
		}

		// CRITICAL: Revoke all sessions for this user (invalidate all existing JWTs including current one)
		if err := authStorage.RevokeSessions(ctx, userUUID); err != nil {
			// Log error but don't fail the request (password was already changed)
			fmt.Printf("[AUTH WARNING] Failed to revoke sessions for user %s: %v\n", userUUID, err)
		}

		response := map[string]interface{}{
			"message": "Password changed successfully. Please log in again with your new password.",
			"success": true,
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(response)
	}
}
