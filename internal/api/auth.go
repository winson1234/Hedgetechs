package api

import (
	"context"
	"crypto/rand"
	"database/sql"
	"encoding/json"
	"fmt"
	"math/big"
	"net/http"
	"strings"
	"time"

	"brokerageProject/internal/config"
	"brokerageProject/internal/database"
	"brokerageProject/internal/middleware"
	"brokerageProject/internal/models"
	"brokerageProject/internal/services"
	"brokerageProject/internal/utils"

	"github.com/google/uuid"
)

// HandleRegister handles user registration requests
func HandleRegister(w http.ResponseWriter, r *http.Request) {
	var req models.RegisterRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		utils.RespondWithJSONError(w, http.StatusBadRequest, "invalid_request", "Invalid request body")
		return
	}

	// Validate required fields
	if req.Email == "" || req.Password == "" || req.FirstName == "" || req.LastName == "" {
		utils.RespondWithJSONError(w, http.StatusBadRequest, "validation_error", "Email, password, first name, and last name are required")
		return
	}

	// Hash password
	hashedPassword, err := utils.HashPassword(req.Password)
	if err != nil {
		utils.RespondWithJSONError(w, http.StatusInternalServerError, "server_error", "Failed to process password")
		return
	}

	// Insert directly into users table
	pool, err := database.GetPool()
	if err != nil {
		utils.RespondWithJSONError(w, http.StatusInternalServerError, "database_error", "Failed to connect to database")
		return
	}
	ctx := context.Background()

	// Generate UUID for user
	userID := uuid.New()
	createdAt := time.Now()

	// user_id will be auto-generated by the database sequence
	query := `
		INSERT INTO users
		(id, first_name, last_name, email, hash_password, phone_number, country, is_active, created_at, last_updated_at)
		VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
	`

	_, err = pool.Exec(ctx, query,
		userID,
		req.FirstName,
		req.LastName,
		req.Email,
		hashedPassword,
		req.PhoneNumber,
		req.Country,
		true, // is_active defaults to true
		createdAt,
		time.Now(),
	)

	if err != nil {
		// Check for duplicate email
		if strings.Contains(err.Error(), "users_email_key") {
			utils.RespondWithJSONError(w, http.StatusConflict, "duplicate_email", "Email already registered")
			return
		}
		utils.RespondWithJSONError(w, http.StatusInternalServerError, "database_error", fmt.Sprintf("Failed to create user account: %v", err))
		return
	}

	// Log successful registration
	if utils.GlobalAuditLogger != nil {
		auditEntry := models.NewAuditLogEntry(userID, "user_registered", models.ResourceTypeUser).
			WithMetadata("email", req.Email).
			WithMetadata("first_name", req.FirstName).
			WithMetadata("last_name", req.LastName).
			WithMetadata("country", req.Country)
		
		if err := utils.GlobalAuditLogger.LogFromRequest(ctx, r, auditEntry); err != nil {
			// Log error but don't fail the registration
			fmt.Printf("[AUDIT WARNING] Failed to log registration audit event: %v\n", err)
		}
	}

	// Success response
	response := models.RegisterResponse{
		Message: "Registration successful. You can now log in.",
		Success: true,
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusCreated)
	json.NewEncoder(w).Encode(response)
}

// HandleCheckStatus checks the registration status of a user
func HandleCheckStatus(w http.ResponseWriter, r *http.Request) {
	var req models.CheckStatusRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		utils.RespondWithJSONError(w, http.StatusBadRequest, "invalid_request", "Invalid request body")
		return
	}

	if req.Email == "" {
		utils.RespondWithJSONError(w, http.StatusBadRequest, "validation_error", "Email is required")
		return
	}

	pool, err := database.GetPool()
	if err != nil {
		utils.RespondWithJSONError(w, http.StatusInternalServerError, "database_error", "Failed to connect to database")
		return
	}
	ctx := context.Background()

	var isActive bool
	query := `SELECT is_active FROM users WHERE email = $1`
	err = pool.QueryRow(ctx, query, req.Email).Scan(&isActive)

	if err != nil {
		response := models.CheckStatusResponse{
			Status:  "not_found",
			Message: "No account found for this email",
		}
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(response)
		return
	}

	var status string
	var message string
	if isActive {
		status = "approved"
		message = "Your account is active. You can log in"
	} else {
		status = "inactive"
		message = "Your account is inactive. Please contact support"
	}

	response := models.CheckStatusResponse{
		Status:  status,
		Message: message,
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(response)
}

// HandleLogin returns a handler that processes login requests with rate limiting
func HandleLogin(authStorage *services.AuthStorageService) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var req models.LoginRequest
		if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
			utils.RespondWithJSONError(w, http.StatusBadRequest, "invalid_request", "Invalid request body")
			return
		}

		if req.Email == "" || req.Password == "" {
			utils.RespondWithJSONError(w, http.StatusBadRequest, "validation_error", "Email and password are required")
			return
		}

		ctx := r.Context()

		// Check rate limit for login attempts (5 attempts per 15 minutes)
		allowed, remaining, err := authStorage.CheckRateLimit(
			ctx,
			config.RateLimitActionLogin,
			req.Email,
			config.LoginMaxAttempts,
			config.LoginWindow,
		)
		if err != nil {
			utils.RespondWithJSONError(w, http.StatusInternalServerError, "server_error", "Failed to check rate limit")
			return
		}

		if !allowed {
			response := map[string]interface{}{
				"error":               "rate_limit_exceeded",
				"message":             "Too many login attempts. Please try again later.",
				"retry_after_seconds": int(config.LoginWindow.Seconds()),
			}
			w.Header().Set("Content-Type", "application/json")
			w.WriteHeader(http.StatusTooManyRequests)
			json.NewEncoder(w).Encode(response)
			return
		}

		pool, err := database.GetPool()
		if err != nil {
			utils.RespondWithJSONError(w, http.StatusInternalServerError, "database_error", "Failed to connect to database")
			return
		}

		// Check users table directly
		var (
			userID         uuid.UUID
			hashedPassword string
			isActive       bool
		)

		query := `
			SELECT id, hash_password, is_active
			FROM users
			WHERE email = $1
		`

		err = pool.QueryRow(ctx, query, req.Email).Scan(
			&userID, &hashedPassword, &isActive,
		)

	if err != nil {
		// Log failed login attempt (user not found)
		if utils.GlobalAuditLogger != nil {
			// Use zero UUID since user doesn't exist
			auditEntry := models.NewAuditLogEntry(uuid.Nil, models.ActionLoginFailure, models.ResourceTypeUser).
				WithMetadata("email", req.Email).
				WithMetadata("reason", "user_not_found").
				WithFailure("Invalid email or password")
			
			if logErr := utils.GlobalAuditLogger.LogFromRequest(ctx, r, auditEntry); logErr != nil {
				fmt.Printf("[AUDIT WARNING] Failed to log failed login audit event: %v\n", logErr)
			}
		}
		
		utils.RespondWithJSONError(w, http.StatusUnauthorized, "authentication_error", "Invalid email or password")
		return
	}

	// Check if account is active
	if !isActive {
		// Log failed login attempt (account inactive)
		if utils.GlobalAuditLogger != nil {
			auditEntry := models.NewAuditLogEntry(userID, models.ActionLoginFailure, models.ResourceTypeUser).
				WithMetadata("email", req.Email).
				WithMetadata("reason", "account_inactive").
				WithFailure("Account is inactive")
			
			if logErr := utils.GlobalAuditLogger.LogFromRequest(ctx, r, auditEntry); logErr != nil {
				fmt.Printf("[AUDIT WARNING] Failed to log failed login audit event: %v\n", logErr)
			}
		}
		
		response := models.LoginResponse{
			Message: "Your account is inactive. Please contact support",
			Status:  "inactive",
		}
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusForbidden)
		json.NewEncoder(w).Encode(response)
		return
	}

	// Verify password
	if err := utils.VerifyPassword(hashedPassword, req.Password); err != nil {
		// Log failed login attempt (invalid password)
		if utils.GlobalAuditLogger != nil {
			auditEntry := models.NewAuditLogEntry(userID, models.ActionLoginFailure, models.ResourceTypeUser).
				WithMetadata("email", req.Email).
				WithMetadata("reason", "invalid_password").
				WithFailure("Invalid email or password")
			
			if logErr := utils.GlobalAuditLogger.LogFromRequest(ctx, r, auditEntry); logErr != nil {
				fmt.Printf("[AUDIT WARNING] Failed to log failed login audit event: %v\n", logErr)
			}
		}
		
		utils.RespondWithJSONError(w, http.StatusUnauthorized, "authentication_error", "Invalid email or password")
		return
	}

		// Update last_login
		updateLoginQuery := `UPDATE users SET last_login = $1 WHERE id = $2`
		pool.Exec(ctx, updateLoginQuery, time.Now(), userID)

		// Generate JWT token with session ID
		token, sessionID, err := utils.GenerateJWT(userID, req.Email)
		if err != nil {
			utils.RespondWithJSONError(w, http.StatusInternalServerError, "server_error", "Failed to generate authentication token")
			return
		}

		// Store session in Redis (active session tracking)
		if authStorage != nil {
			if err := authStorage.StoreSession(ctx, userID.String(), sessionID); err != nil {
				// Log error but don't fail the login (graceful degradation)
				fmt.Printf("[SESSION WARNING] Failed to store session in Redis: %v\n", err)
			}
		}

		// Get user info
		var user models.UserInfo
		getUserQuery := `
			SELECT id, user_id, email, first_name, last_name, phone_number, country, is_active
			FROM users
			WHERE id = $1
		`
		err = pool.QueryRow(ctx, getUserQuery, userID).Scan(
			&user.ID,
			&user.UserID,
			&user.Email,
			&user.FirstName,
			&user.LastName,
			&user.PhoneNumber,
			&user.Country,
			&user.IsActive,
		)

		if err != nil {
			utils.RespondWithJSONError(w, http.StatusInternalServerError, "database_error", "Failed to retrieve user information")
			return
		}

		// Log successful login
		if utils.GlobalAuditLogger != nil {
			auditEntry := models.NewAuditLogEntry(userID, models.ActionLoginSuccess, models.ResourceTypeUser).
				WithMetadata("email", req.Email).
				WithMetadata("user_id", user.UserID).
				WithMetadata("session_id", sessionID)
			
			if logErr := utils.GlobalAuditLogger.LogFromRequest(ctx, r, auditEntry); logErr != nil {
				// Log error but don't fail the login
				fmt.Printf("[AUDIT WARNING] Failed to log successful login audit event: %v\n", logErr)
			}
		}

		// Success response
		response := models.LoginResponse{
			Token:   token,
			User:    &user,
			Message: "Login successful",
			Status:  "approved",
		}

		w.Header().Set("Content-Type", "application/json")
		w.Header().Set("X-RateLimit-Remaining", fmt.Sprintf("%d", remaining-1))
		json.NewEncoder(w).Encode(response)
	}
}

// generateOTP generates a random 6-digit OTP
func generateOTP() (string, error) {
	max := big.NewInt(1000000)
	n, err := rand.Int(rand.Reader, max)
	if err != nil {
		return "", err
	}
	return fmt.Sprintf("%06d", n.Int64()), nil
}

// generateResetToken generates a random reset token
func generateResetToken() (string, error) {
	b := make([]byte, 32)
	_, err := rand.Read(b)
	if err != nil {
		return "", err
	}
	return fmt.Sprintf("%x", b), nil
}

// HandleForgotPassword returns a handler that processes forgot password requests with rate limiting
func HandleForgotPassword(authStorage *services.AuthStorageService, emailSender services.EmailSender) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var req models.ForgotPasswordRequest
		if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
			utils.RespondWithJSONError(w, http.StatusBadRequest, "invalid_request", "Invalid request body")
			return
		}

		if req.Email == "" {
			utils.RespondWithJSONError(w, http.StatusBadRequest, "validation_error", "Email is required")
			return
		}

		ctx := r.Context()

		// CRITICAL: Check rate limit FIRST using configured limits
		allowed, remaining, err := authStorage.CheckRateLimit(
			ctx, 
			config.RateLimitActionForgotPassword, 
			req.Email, 
			config.OTPRequestMaxAttempts, 
			config.OTPRequestWindow,
		)
		if err != nil {
			utils.RespondWithJSONError(w, http.StatusInternalServerError, "server_error", "Failed to check rate limit")
			return
		}

		if !allowed {
			response := map[string]interface{}{
				"error":               "rate_limit_exceeded",
				"message":             "Too many password reset attempts. Please try again later.",
				"retry_after_seconds": 3600,
			}
			w.Header().Set("Content-Type", "application/json")
			w.WriteHeader(http.StatusTooManyRequests)
			json.NewEncoder(w).Encode(response)
			return
		}

		pool, err := database.GetPool()
		if err != nil {
			utils.RespondWithJSONError(w, http.StatusInternalServerError, "database_error", "Failed to connect to database")
			return
		}

		// Constant-time user lookup (prevent timing attacks)
		// CRITICAL: Check users table, not pending_registrations
		// Only allow password reset for registered, active users
		var isActive bool
		var userFound bool
		query := `SELECT is_active FROM users WHERE email = $1`
		err = pool.QueryRow(ctx, query, req.Email).Scan(&isActive)

		if err == nil && isActive {
			userFound = true
		}

		// Always sleep to prevent timing attacks (even if user not found)
		time.Sleep(200 * time.Millisecond)

		// Generic response regardless of user existence (prevent email enumeration)
		response := models.ForgotPasswordResponse{
			Message: "If your email is registered and approved, you will receive a verification code shortly.",
			Status:  "success",
			Success: true,
		}

		// Only actually send OTP if user was found and approved
		if userFound {
			// Generate OTP
			otp, err := generateOTP()
			if err != nil {
				utils.RespondWithJSONError(w, http.StatusInternalServerError, "server_error", "Failed to generate OTP")
				return
			}

			// Store OTP in Redis with 10-minute TTL
			if err := authStorage.StoreOTP(ctx, req.Email, otp); err != nil {
				utils.RespondWithJSONError(w, http.StatusInternalServerError, "server_error", "Failed to store OTP")
				return
			}

			// Send OTP via email service (Console in dev, Resend in prod)
			if err := emailSender.SendOTP(ctx, req.Email, otp); err != nil {
				utils.RespondWithJSONError(w, http.StatusInternalServerError, "server_error", "Failed to send OTP email")
				return
			}
		}

		w.Header().Set("Content-Type", "application/json")
		w.Header().Set("X-RateLimit-Remaining", fmt.Sprintf("%d", remaining-1))
		json.NewEncoder(w).Encode(response)
	}
}

// HandleVerifyOTP returns a handler that processes OTP verification requests with rate limiting
func HandleVerifyOTP(authStorage *services.AuthStorageService) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var req models.VerifyOTPRequest
		if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
			utils.RespondWithJSONError(w, http.StatusBadRequest, "invalid_request", "Invalid request body")
			return
		}

		if req.Email == "" || req.OTP == "" {
			utils.RespondWithJSONError(w, http.StatusBadRequest, "validation_error", "Email and OTP are required")
			return
		}

		ctx := r.Context()

		// Check rate limit for OTP verification attempts (5 attempts per 5 minutes)
		allowed, remaining, err := authStorage.CheckRateLimit(
			ctx,
			config.RateLimitActionOTPVerify,
			req.Email,
			config.OTPVerifyMaxAttempts,
			config.OTPVerifyWindow,
		)
		if err != nil {
			utils.RespondWithJSONError(w, http.StatusInternalServerError, "server_error", "Failed to check rate limit")
			return
		}

		if !allowed {
			response := map[string]interface{}{
				"error":               "rate_limit_exceeded",
				"message":             "Too many OTP verification attempts. Please try again later.",
				"retry_after_seconds": int(config.OTPVerifyWindow.Seconds()),
			}
			w.Header().Set("Content-Type", "application/json")
			w.WriteHeader(http.StatusTooManyRequests)
			json.NewEncoder(w).Encode(response)
			return
		}

		// Validate OTP from Redis with detailed error information
		validationResult := authStorage.ValidateOTPWithDetails(ctx, req.Email, req.OTP)
		
		if !validationResult.Valid {
			// Determine response based on error code
			var message string
			var errorCode string
			
			switch validationResult.ErrorCode {
			case config.ErrorCodeOTPExpired:
				message = "OTP has expired. Please request a new one."
				errorCode = config.ErrorCodeOTPExpired
			case config.ErrorCodeOTPInvalid:
				message = "Invalid OTP code. Please check and try again."
				errorCode = config.ErrorCodeOTPInvalid
			default:
				message = "Invalid or expired OTP. Please request a new one."
				errorCode = config.ErrorCodeOTPInvalid
			}

			// Log failed OTP verification attempt
			if utils.GlobalAuditLogger != nil {
				auditEntry := models.NewAuditLogEntry(uuid.Nil, "otp_verification_failed", models.ResourceTypeUser).
					WithMetadata("email", req.Email).
					WithMetadata("error_code", validationResult.ErrorCode).
					WithMetadata("reason", message).
					WithFailure(message)
				
				if logErr := utils.GlobalAuditLogger.LogFromRequest(ctx, r, auditEntry); logErr != nil {
					fmt.Printf("[AUDIT WARNING] Failed to log OTP verification failure: %v\n", logErr)
				}
			}

			response := map[string]interface{}{
				"error":   errorCode,
				"message": message,
				"success": false,
			}
			w.Header().Set("Content-Type", "application/json")
			w.Header().Set("X-RateLimit-Remaining", fmt.Sprintf("%d", remaining-1))
			w.WriteHeader(http.StatusUnauthorized)
			json.NewEncoder(w).Encode(response)
			return
		}

		// OTP is valid - generate reset token
		resetToken, err := generateResetToken()
		if err != nil {
			utils.RespondWithJSONError(w, http.StatusInternalServerError, "server_error", "Failed to generate reset token")
			return
		}

		// Store reset token in Redis with configurable TTL
		if err := authStorage.StoreResetToken(ctx, resetToken, req.Email); err != nil {
			utils.RespondWithJSONError(w, http.StatusInternalServerError, "server_error", "Failed to store reset token")
			return
		}

		// Log successful OTP verification
		if utils.GlobalAuditLogger != nil {
			auditEntry := models.NewAuditLogEntry(uuid.Nil, "otp_verification_success", models.ResourceTypeUser).
				WithMetadata("email", req.Email)
			
			if logErr := utils.GlobalAuditLogger.LogFromRequest(ctx, r, auditEntry); logErr != nil {
				fmt.Printf("[AUDIT WARNING] Failed to log OTP verification success: %v\n", logErr)
			}
		}

		response := models.VerifyOTPResponse{
			Message:    "OTP verified successfully. You can now reset your password.",
			Success:    true,
			ResetToken: resetToken,
		}

		w.Header().Set("Content-Type", "application/json")
		w.Header().Set("X-RateLimit-Remaining", fmt.Sprintf("%d", remaining-1))
		json.NewEncoder(w).Encode(response)
	}
}

// HandleResetPassword returns a handler that processes password reset requests with session revocation
func HandleResetPassword(authStorage *services.AuthStorageService) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var req models.ResetPasswordRequest
		if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
			utils.RespondWithJSONError(w, http.StatusBadRequest, "invalid_request", "Invalid request body")
			return
		}

		if req.ResetToken == "" || req.NewPassword == "" {
			utils.RespondWithJSONError(w, http.StatusBadRequest, "validation_error", "Reset token and new password are required")
			return
		}

		// Validate password strength
		if len(req.NewPassword) < 8 {
			utils.RespondWithJSONError(w, http.StatusBadRequest, "validation_error", "Password must be at least 8 characters")
			return
		}

		ctx := r.Context()

		// Validate reset token from Redis (auto-deletes on success - one-time use)
		email, err := authStorage.ValidateResetToken(ctx, req.ResetToken)
		if err != nil {
			response := models.ResetPasswordResponse{
				Message: "Invalid or expired reset token. Please request a new OTP.",
				Success: false,
			}
			w.Header().Set("Content-Type", "application/json")
			w.WriteHeader(http.StatusUnauthorized)
			json.NewEncoder(w).Encode(response)
			return
		}

		// Hash new password
		hashedPassword, err := utils.HashPassword(req.NewPassword)
		if err != nil {
			utils.RespondWithJSONError(w, http.StatusInternalServerError, "server_error", "Failed to process password")
			return
		}

		pool, err := database.GetPool()
		if err != nil {
			utils.RespondWithJSONError(w, http.StatusInternalServerError, "database_error", "Failed to connect to database")
			return
		}

		// Update users table and get UUID
		var userUUID string
		updateUsersQuery := `
			UPDATE users
			SET hash_password = $1, last_updated_at = NOW()
			WHERE email = $2 AND is_active = true
			RETURNING id
		`
		err = pool.QueryRow(ctx, updateUsersQuery, hashedPassword, email).Scan(&userUUID)

		if err == sql.ErrNoRows {
			// User not found or not active
			utils.RespondWithJSONError(w, http.StatusNotFound, "not_found", "User not found or account inactive")
			return
		}

		if err != nil {
			// Database error
			utils.RespondWithJSONError(w, http.StatusInternalServerError, "database_error", "Failed to update password in users table")
			return
		}

		// CRITICAL: Revoke all sessions for this user (invalidate existing JWTs)
		if err := authStorage.RevokeSessions(ctx, userUUID); err != nil {
			// Log error but don't fail the request (password was already reset)
			fmt.Printf("[AUTH WARNING] Failed to revoke sessions for user %s: %v\n", userUUID, err)
		}

		// Log successful password reset
		if utils.GlobalAuditLogger != nil {
			userUUIDParsed, _ := uuid.Parse(userUUID)
			auditEntry := models.NewAuditLogEntry(userUUIDParsed, models.ActionPasswordChanged, models.ResourceTypeUser).
				WithMetadata("email", email).
				WithMetadata("method", "password_reset")
			
			if logErr := utils.GlobalAuditLogger.LogFromRequest(ctx, r, auditEntry); logErr != nil {
				fmt.Printf("[AUDIT WARNING] Failed to log password reset audit event: %v\n", logErr)
			}
		}

		response := models.ResetPasswordResponse{
			Message: "Password reset successfully. You can now log in with your new password.",
			Success: true,
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(response)
	}
}

// HandleChangePassword returns a handler that processes authenticated password change requests with session revocation
func HandleChangePassword(authStorage *services.AuthStorageService) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var req models.ChangePasswordRequest
		if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
			utils.RespondWithJSONError(w, http.StatusBadRequest, "invalid_request", "Invalid request body")
			return
		}

		if req.CurrentPassword == "" || req.NewPassword == "" {
			utils.RespondWithJSONError(w, http.StatusBadRequest, "validation_error", "Current password and new password are required")
			return
		}

		// Validate new password strength
		if len(req.NewPassword) < 8 {
			utils.RespondWithJSONError(w, http.StatusBadRequest, "validation_error", "New password must be at least 8 characters")
			return
		}

		// Check that new password is different from current
		if req.CurrentPassword == req.NewPassword {
			utils.RespondWithJSONError(w, http.StatusBadRequest, "validation_error", "New password must be different from current password")
			return
		}

		ctx := r.Context()

		// Extract user email from JWT context (injected by AuthMiddleware)
		email, err := middleware.GetUserEmailFromContext(ctx)
		if err != nil {
			utils.RespondWithJSONError(w, http.StatusUnauthorized, "authentication_error", "User email not found in context")
			return
		}

		pool, err := database.GetPool()
		if err != nil {
			utils.RespondWithJSONError(w, http.StatusInternalServerError, "database_error", "Failed to connect to database")
			return
		}

		// Get current password hash and UUID from users table
		var currentHashedPassword string
		var userUUID string
		userQuery := `SELECT id, hash_password FROM users WHERE email = $1`
		err = pool.QueryRow(ctx, userQuery, email).Scan(&userUUID, &currentHashedPassword)
		if err != nil {
			utils.RespondWithJSONError(w, http.StatusInternalServerError, "database_error", "Failed to retrieve user information")
			return
		}

		// Verify current password
		if err := utils.VerifyPassword(currentHashedPassword, req.CurrentPassword); err != nil {
			utils.RespondWithJSONError(w, http.StatusUnauthorized, "authentication_error", "Current password is incorrect")
			return
		}

		// Hash new password
		newHashedPassword, err := utils.HashPassword(req.NewPassword)
		if err != nil {
			utils.RespondWithJSONError(w, http.StatusInternalServerError, "server_error", "Failed to process new password")
			return
		}

		// Update users table
		updateUsersQuery := `UPDATE users SET hash_password = $1, last_updated_at = NOW() WHERE email = $2`
		_, err = pool.Exec(ctx, updateUsersQuery, newHashedPassword, email)
		if err != nil {
			utils.RespondWithJSONError(w, http.StatusInternalServerError, "database_error", "Failed to update password in users table")
			return
		}

		// CRITICAL: Revoke all sessions for this user (invalidate all existing JWTs including current one)
		if err := authStorage.RevokeSessions(ctx, userUUID); err != nil {
			// Log error but don't fail the request (password was already changed)
			fmt.Printf("[AUTH WARNING] Failed to revoke sessions for user %s: %v\n", userUUID, err)
		}

		// Log successful password change
		if utils.GlobalAuditLogger != nil {
			userUUIDParsed, _ := uuid.Parse(userUUID)
			auditEntry := models.NewAuditLogEntry(userUUIDParsed, models.ActionPasswordChanged, models.ResourceTypeUser).
				WithMetadata("email", email).
				WithMetadata("method", "authenticated_change")
			
			if logErr := utils.GlobalAuditLogger.LogFromRequest(ctx, r, auditEntry); logErr != nil {
				fmt.Printf("[AUDIT WARNING] Failed to log password change audit event: %v\n", logErr)
			}
		}

		response := map[string]interface{}{
			"message": "Password changed successfully. Please log in again with your new password.",
			"success": true,
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(response)
	}
}

// HandleLogout returns a handler that processes logout requests and invalidates the session
func HandleLogout(authStorage *services.AuthStorageService) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// Get user email from context (injected by auth middleware)
		email, err := middleware.GetUserEmailFromContext(r.Context())
		if err != nil {
			utils.RespondWithJSONError(w, http.StatusUnauthorized, "authentication_error", "User not authenticated")
			return
		}
		
		// Get user UUID from token
		authHeader := r.Header.Get("Authorization")
		if authHeader == "" {
			utils.RespondWithJSONError(w, http.StatusUnauthorized, "missing_token", "Authorization header required")
			return
		}
		
		parts := strings.SplitN(authHeader, " ", 2)
		if len(parts) != 2 || parts[0] != "Bearer" {
			utils.RespondWithJSONError(w, http.StatusUnauthorized, "invalid_token_format", "Invalid authorization format")
			return
		}
		
		tokenString := parts[1]
		claims, err := utils.ValidateJWT(tokenString)
		if err != nil {
			utils.RespondWithJSONError(w, http.StatusUnauthorized, "invalid_token", "Invalid or expired token")
			return
		}
		
		userUUID := claims.UserID
		sessionID := claims.SessionID
		ctx := r.Context()
		
		// Delete the session from Redis
		if authStorage != nil && sessionID != "" {
			if err := authStorage.DeleteSession(ctx, userUUID, sessionID); err != nil {
				// Log error but don't fail the logout
				fmt.Printf("[SESSION WARNING] Failed to delete session from Redis: %v\n", err)
			}
		}
		
		// Parse UUID for audit log
		userIDForAudit, _ := uuid.Parse(userUUID)
		
		// Log successful logout
		if utils.GlobalAuditLogger != nil {
			auditEntry := models.NewAuditLogEntry(userIDForAudit, "user_logout", models.ResourceTypeUser).
				WithMetadata("email", email).
				WithMetadata("session_id", sessionID)
			
			if logErr := utils.GlobalAuditLogger.LogFromRequest(ctx, r, auditEntry); logErr != nil {
				fmt.Printf("[AUDIT WARNING] Failed to log logout audit event: %v\n", logErr)
			}
		}
		
		// Success response
		response := map[string]interface{}{
			"message": "Logout successful",
			"success": true,
		}
		
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(response)
	}
}

// HandleLogoutAll returns a handler that logs out from all devices/sessions
func HandleLogoutAll(authStorage *services.AuthStorageService) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// Get user email from context (injected by auth middleware)
		email, err := middleware.GetUserEmailFromContext(r.Context())
		if err != nil {
			utils.RespondWithJSONError(w, http.StatusUnauthorized, "authentication_error", "User not authenticated")
			return
		}
		
		// Get user UUID from token
		authHeader := r.Header.Get("Authorization")
		if authHeader == "" {
			utils.RespondWithJSONError(w, http.StatusUnauthorized, "missing_token", "Authorization header required")
			return
		}
		
		parts := strings.SplitN(authHeader, " ", 2)
		if len(parts) != 2 || parts[0] != "Bearer" {
			utils.RespondWithJSONError(w, http.StatusUnauthorized, "invalid_token_format", "Invalid authorization format")
			return
		}
		
		tokenString := parts[1]
		claims, err := utils.ValidateJWT(tokenString)
		if err != nil {
			utils.RespondWithJSONError(w, http.StatusUnauthorized, "invalid_token", "Invalid or expired token")
			return
		}
		
		userUUID := claims.UserID
		ctx := r.Context()
		
		// Delete all sessions for this user from Redis
		var deletedCount int64
		if authStorage != nil {
			deletedCount, err = authStorage.DeleteAllUserSessions(ctx, userUUID)
			if err != nil {
				// Log error but don't fail the logout
				fmt.Printf("[SESSION WARNING] Failed to delete all sessions from Redis: %v\n", err)
			}
		}
		
		// Parse UUID for audit log
		userIDForAudit, _ := uuid.Parse(userUUID)
		
		// Log successful logout from all devices
		if utils.GlobalAuditLogger != nil {
			auditEntry := models.NewAuditLogEntry(userIDForAudit, "user_logout_all", models.ResourceTypeUser).
				WithMetadata("email", email).
				WithMetadata("sessions_deleted", deletedCount)
			
			if logErr := utils.GlobalAuditLogger.LogFromRequest(ctx, r, auditEntry); logErr != nil {
				fmt.Printf("[AUDIT WARNING] Failed to log logout-all audit event: %v\n", logErr)
			}
		}
		
		// Success response
		response := map[string]interface{}{
			"message":          "Logged out from all devices",
			"success":          true,
			"sessions_deleted": deletedCount,
		}
		
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(response)
	}
}
